from typing import Union, List, Callable

import numpy as np
from sklearn.metrics.pairwise import cosine_similarity, cosine_distances


def novelty(recommendations: Union[List, np.ndarray],
            user_profile: Union[List, np.ndarray],
            mode: Callable = np.mean) -> np.ndarray:
    """
    Calculates novelty of recommendations for user with profile `user_profile`.
    :param recommendations: Recommendations as embeddings.
    :param user_profile: User profile.
    :param mode: Aggregation function.
    :return: Number from [0, 1], where 0 means items aren't novel, 1 items are novel.
    """
    return mode(cosine_distances(recommendations, user_profile), axis=1)


def unexpectedness(recommendations, primitive_recommendations):
    return np.array([~np.isin(recommendations, primitive_recommendations) for primitive_recommendations in primitive_recommendations]).mean(axis=0)


def relevance(recommendations, user_profile, mode=np.mean):
    """
    Calculates relevance of recommendation for user with profile `user_profile`.
    :param recommendations: Recommendations as embeddings.
    :param user_profile: User profile.
    :param mode: Aggregation function.
    :return: Number from [0, 1], where 0 means items aren't relevant, 1 items are relevant.
    """
    return mode(cosine_similarity(recommendations, user_profile), axis=1)


def serendipity(items: Union[List, np.ndarray],
                recommendations: Union[List, np.ndarray],
                primitive_recommendations: Union[List, np.ndarray],
                user_profile: Union[List, np.ndarray],
                keepdims: bool = False,
                verbose: bool = False) -> Union[int, np.ndarray]:
    """
    Calculate the serendipity of recommendation list.

    :param items: Recommended items as one-hot encoded vectors.
    :param recommendations: Recommendation's id list.
    :param primitive_recommendations: Primitive recommendation's id list (generated by simple algorithm).
    :param user_profile: One-hot encoded vectors of user's rated items.
    :param keepdims: Return score for each entry when True, return mean score otherwise.
    :param verbose: Print intermediate results if set to True, doesn't otherwise.
    :return: A number from [0, 1] interval. 1 is a maximum, 0 is a minimum.
    """

    _novelty = novelty(items, user_profile, mode=np.min)
    _unexpectedness = unexpectedness(recommendations, primitive_recommendations)
    _relevance = 0  # relevance(items, user_profile)

    if verbose:
        print('Novelty: {}, relevance: {}, unexp: {}'.format(_novelty, _relevance, _unexpectedness))

    if keepdims:
        return _novelty + _relevance + np.mean(_unexpectedness)
    else:
        return np.mean(np.vstack((_novelty, _relevance, _unexpectedness)), axis=(0, 1))

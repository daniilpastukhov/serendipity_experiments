from typing import Union, List, Callable

import numpy as np
from sklearn.metrics.pairwise import cosine_similarity, cosine_distances
from scipy.spatial.distance import cosine


def similarity(i: Union[List, np.ndarray],
               j: Union[List, np.ndarray]):
    """
    Calculates similarity between two items.
    :param i: First item (one-hot vector).
    :param j: Second item (one-hot vector).
    :return: Number from [0, 1], where 0 means items are completely different, 1 items are the same.
    """
    # return (cosine_similarity([i], [j])[0] + 1) / 2  # map range from [-1, 1] to [0, 1]
    res = 1.0 - cosine(i, j)
    return res if not np.isnan(res) else 0


def distance(i: Union[List, np.ndarray],
             j: Union[List, np.ndarray]):
    """
    Calculates distance between two items.
    :param i: First item (one-hot vector).
    :param j: Second item (one-hot vector).
    :return: Number from [0, 1], where 0 means items are the same, 1 items are completely different.
    """
    return 1.0 - similarity(i, j)


def novelty(recommendations: Union[List, np.ndarray],
            user_profile: Union[List, np.ndarray],
            mode: Callable = np.mean):
    """
    Calculates novelty of recommendation for user with profile `user_profile`.
    :param recommendations: Recommendations as embeddings.
    :param user_profile: User profile.
    :param mode: Aggregation function.
    :return: Number from [0, 1], where 0 means items aren't novel, 1 items are novel.
    """
    return mode(cosine_distances(recommendations, user_profile), axis=1)


def unexpectedness(recommendations: Union[List, np.ndarray],
                   primitive_recommendations: Union[List, np.ndarray]):
    return np.array([~np.isin(recommendations, row) for row in primitive_recommendations]).mean(axis=0)


def relevance(recommendations: Union[List, np.ndarray],
              user_profile: Union[List, np.ndarray],
              mode: Callable = np.mean):
    """
    Calculates relevance of recommendation for user with profile `user_profile`.
    :param recommendations: Recommendations as embeddings.
    :param user_profile: User profile.
    :param mode: Aggregation function.
    :return: Number from [0, 1], where 0 means items aren't relevant, 1 items are relevant.
    """
    return mode(cosine_similarity(recommendations, user_profile), axis=1)


def serendipity(items: Union[List, np.ndarray],
                recommendations: Union[List, np.ndarray],
                primitive_recommendations: Union[List, np.ndarray],
                user_profile: Union[List, np.ndarray],
                keepdims: bool = False,
                verbose: bool = False):
    """
    Serendipity of recommendation list.

    :param items: Recommended items as one-hot encoded vectors.
    :param recommendations: Recommendation's id list.
    :param primitive_recommendations: Primitive recommendation's id list (generated by simple algorithm).
    :param user_profile: One-hot encoded vectors of user's rated items.
    :param keepdims: Return score for each entry when True, return mean score otherwise.
    :param verbose: Print intermediate results if set to True, doesn't otherwise.
    :return: A number from [0, 1] interval. 1 is a maximum, 0 is a minimum.
    """

    _novelty = novelty(items, user_profile)
    _unexpectedness = unexpectedness(recommendations, primitive_recommendations)
    _relevance = relevance(items, user_profile)

    if verbose:
        print('Novelty: {}, relevance: {}, unexp: {}'.format(_novelty, _relevance, _unexpectedness))

    if keepdims:
        return _novelty + _relevance + np.mean(_unexpectedness)
    else:
        return np.mean(np.mean(_novelty) + np.mean(_relevance) + np.mean(_unexpectedness))
